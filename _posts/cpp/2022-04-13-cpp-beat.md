---
layout: post
title: '[C++] 비트마스크(BitMask)'
image: /assets/postimage/BitMask.jpg
description: >
  C/C++ Bit
categories:
  - C++
hashtag: C++
toc: true
toc_sticky: true
date: 2022-04-13
---


<br>

## 비트 연산자의 정의

- 비트 연산자는 32비트(0과 1)의 집합으로 표현하는 연산자이다.
- 비트 연산자를 사용할 경우 프로그램의 용량을 줄일 수 있고, 속도도 증가하는 장점을 가진다.
- 비트 단위 연산자는 2진수 형태의 비트 자리별로 논리연산을 한다.
- 10진수와 2진수 변환을 할줄 알아야 한다.

<br>

## 10진수를 2진수로 바꾸는 법

![800x400](https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3921/11482.png)

<br>

아래 코드를 작성하고 실행해보자.
```c++
#include <stdio.h>

main ()
{
   printf ( "%d %d \n", 3 & 1, 3 | 1);
   printf ( "%d \n", 3 ^ 1);
   printf ( "%d %d \n", 3 << 1, 3 >> 1);
}
```
<br>

위 프로그램을 실행하면 숫자데이터를 2진수로 변환한 후 **비트별**로 논리연산을 실행한 결과를 출력한다.

<br>

![200x200](https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3921/9945.png)
<br>
- 4행에서 비트 연산자 '&' 와 ' ㅣ ' 는 각각 논리곱과 논리합 연산을 비트 단위로 수행한다. 따라서 3의 비트 값 11과 1의 비트 값 01의 논리곱을 비트 단위로 수행한 결과 1(이진수는01)을 출력하게 되고 같은 방식으로 비트 논리합 연산의 결과는 3(이진수는 11)이 출력된다.  
- 5행에서 비트 연산자 '^' 은 배타적 논리합 연산을 비트 단위로 수행한다. 배타적 논리합 연산은 두 비트의 값이 다를 때만 참(1)이 되는 연산 이므로, 연산 결과는 2가 된다.  
- 6행에서'<<'와 '>>'은 비트 열을 일정 길이 만큼 이동시키는 시프트 연산자이다.

**논리곱(AND, &)**

두 값의 각 자릿수를 비교해, 두 값 모두에 1이 있을 때에만 1을, 나머지 경우에는 0을 계산한다..  
(예시: 1100(12)과 1010(10)을 비교할때, 1000(8)이 된다. )


**논리합(OR, ㅣ)**

두 값의 각 자릿수를 비교해, 둘 중 하나라도 1이 있다면 1을, 아니면 0을 계산한다..  
(예시: 1100(12)과 1010(10)을 비교할때 1110(14)이 된다. )

**배타적 논리합(XOR, ^)**

두 값의 각 자릿수를 비교해,값이 0으로 같으면 0, 값이 1로 같아도 0, 다르면 1을 계산한다.   
(예시: 1100(12)과 1010(“10)을 비교할때 0110(6)이 된다.)

**NOT 연산(~)**

바트의 값을 반전하여 반환한다.   
(예시: 1010을  NOT 연산하면 0101이 된다.)


**쉬프트(shift, << or >>)**

대상의 값을 2진 비트로 바꾼 후에 특정 비트 수만큼 이동 시키고 빈자리는 0으로 채우는 연산자이다.  
3<<1은 정수3을 1비트 만큼 왼쪽으로 이동시키며, 3>>1은 정수3을 1비트만큼 오른쪽으로 이동시킨다.  
(예시)
3<<1은 3(11)이 왼쪽으로 1비트만큼 이동하므로 6(110)이 되며,  
3>>1은 3(11)이 오른쪽으로 1비트만큼 이동시키므로 1(01)이 되며 1의 자리 이하의 숫자는 절삭된다.

<br>

**비트 연산자의 종류**

![200x200](https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3921/9946.png)


# BitMask

### 비트마스크는 무엇인가?

정수의 이진수표현을 활용한 기법이다.  
integer형으로 인덱스를 활용할 수 있다면, 단순히 boolean 배열을 통해 구현할 수도 있다.
```c++
int[] array1 = [1, 1, 1, 1, 0];
int[] array2 = [1, 1, 0, 1, 0];
int[] array3 = [1, 0, 1, 0, 0];
```

하지만 이건 많은 메모리를 차지하고 오버헤드가 증가한다.  
비트마스크를 통해 더욱 효율적이게 할 수 있다.

```
{ 0, 1, 2, 3, 4 } => 11111
{ 1, 2, 3, 4 } => 11110
{ 1, 2, 4 } => 10110
{ 2, 4 } => 10100
{ 1 } => 00010
```

각 요소는 인덱스처럼 표현 할 수 있다.  
즉 집합 i 번쨰 요소가 부분집합에 존재한다면 1을 의미하고, 그렇지 않으면 0 을 의미한다.  
2진수를 10진수로 표현 할 수도 있다.

```
{ 0, 1, 2, 3, 4 } => 11111 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) + (2^0 * 1) = 31
{ 1, 2, 3, 4 } => 11110 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) = 30
{ 1, 2, 4 } => 10110 => (2^4 * 1) + (2^2 * 1) + (2^1 * 1) = 22
{ 2, 4 } => 10100 => (2^4 * 1) + (2^2 * 1) = 20
{ 1 } => 00010 => (2^1 * 1) = 2
```
<br>

부분집합을 배열이 아닌 정수를 통해 나타낼 수 있게 된다.  
즉, 20 이란 정수는 부분집합 { 2, 4 } 를 나타내는 것을 의미한다.  
{ 2, 4 } 부분집합에서 i를 추가하고 싶으면, 단순히 i번째 비트의 값을 1로 변경해주면 된다.  
이러한 삽입, 삭제, 조회와 같은 행위는 비트 연산을 통해 쉽게 제어할 수 있다.

<br>

**1010 로 표현하고 있을 때, i번째 비트의 값을 1로 어떻게 변경할 수 있을까?**
```
1010 | 1 << 2
1010 | 0100 => 1110
```
시프트 연산을 통해 2번째 비트만 1로 할당되어 있는 이진수를 만든다.  
그리고 OR 연산을 통해 원하는 결과를 만들 수 있다.

**반대로 2번째 비트의 값을 0으로 어떻게 변경할 수 있을까?**
```
1110 & ~1 << 2
1110 & 1011 => 1010
```
AND연산과 NOT 연산을 활용할 수 있다.

**i번째 비트의 값을 알 수 있는 방법**
```
A & (1 << i)
2번째 비트 - 1010 & (1 << 2) = 1010 & 0100 => 0
3번째 비트 - 1010 & (1 << 3) = 1010 & 1000 => 1000
```

AND연산과 시프트 연산을 통해 i번째 비트의 값이 0이라면 값이 0 이라는 것을 알 수 있다.  
이렇게 비트를 활용한 테크닉을 통해 접근하는것이 비트마스크이다.


<br>
<br>
<br>

### Reference

- [https://mygumi.tistory.com/361](https://mygumi.tistory.com/361)
- [https://opentutorials.org/module/3921/23697](https://opentutorials.org/module/3921/23697)
